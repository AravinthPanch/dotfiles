#!/bin/zsh

# File Organiser Script
# Combines: rename by date, remove version tags, move duplicates, param-case conversion
# Usage: ./arm-util-file-org [folder_path]

# Colours for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Colour

# Global variable for target folder
TARGET_FOLDER=""

# Function to select folder
select_folder() {
    echo "\n${CYAN}========================================${NC}"
    echo "${CYAN}       Select Target Folder${NC}"
    echo "${CYAN}========================================${NC}"
    echo ""
    echo "1) Current directory ($(pwd))"
    echo "2) Enter custom path"
    echo "0) Back to main menu"
    echo ""
    echo -n "Select an option: "
    read folder_choice
    
    case $folder_choice in
        1)
            TARGET_FOLDER="."
            echo "${GREEN}âœ“ Using current directory: $(pwd)${NC}"
            ;;
        2)
            echo -n "\nEnter folder path: "
            read custom_path
            
            # Expand ~ to home directory
            custom_path="${custom_path/#\~/$HOME}"
            
            if [[ -d "$custom_path" ]]; then
                TARGET_FOLDER="$custom_path"
                echo "${GREEN}âœ“ Using folder: $TARGET_FOLDER${NC}"
            else
                echo "${RED}âœ— Folder does not exist!${NC}"
                TARGET_FOLDER=""
                return 1
            fi
            ;;
        0)
            return 1
            ;;
        *)
            echo "${RED}Invalid option!${NC}"
            return 1
            ;;
    esac
    
    return 0
}

# Function to display menu
show_menu() {
    echo "\n${BLUE}========================================${NC}"
    echo "${BLUE}       File Organiser Script${NC}"
    echo "${BLUE}========================================${NC}"
    
    if [[ -n "$TARGET_FOLDER" ]]; then
        echo "${GREEN}Current folder: $TARGET_FOLDER${NC}"
    else
        echo "${YELLOW}No folder selected${NC}"
    fi
    
    echo ""
    echo "1) ${GREEN}Preview${NC} - Rename files by date"
    echo "2) ${RED}Execute${NC} - Rename files by date"
    echo ""
    echo "3) ${GREEN}Preview${NC} - Remove version tags"
    echo "4) ${RED}Execute${NC} - Remove version tags"
    echo ""
    echo "5) ${GREEN}Preview${NC} - Move duplicate filenames"
    echo "6) ${RED}Execute${NC} - Move duplicate filenames"
    echo ""
    echo "7) ${GREEN}Preview${NC} - Convert to param-case"
    echo "8) ${RED}Execute${NC} - Convert to param-case"
    echo ""
    echo "9) ${YELLOW}Run all previews${NC}"
    echo "a) ${RED}Execute all actions${NC}"
    echo ""
    echo "d) Delete exiftool backup files"
    echo ""
    echo "${CYAN}f) Change folder${NC}"
    echo "0) Exit"
    echo ""
}

# Check if folder is selected
check_folder() {
    if [[ -z "$TARGET_FOLDER" ]]; then
        echo "${RED}âœ— No folder selected! Please select a folder first.${NC}"
        return 1
    fi
    return 0
}

# Function to draw progress bar
draw_progress_bar() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((width * current / total))
    local empty=$((width - filled))
    
    printf "\r${CYAN}Progress: [${NC}"
    printf "%${filled}s" | tr ' ' 'â–ˆ'
    printf "%${empty}s" | tr ' ' 'â–‘'
    printf "${CYAN}] ${GREEN}%d/%d${NC} (${YELLOW}%d%%${NC})" "$current" "$total" "$percentage"
}

# Function to convert string to param-case
to_param_case() {
    local input="$1"
    local output=""
    
    # Remove leading/trailing spaces
    input=$(echo "$input" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    # Convert to lowercase and replace spaces, underscores with hyphens
    output=$(echo "$input" | tr '[:upper:]' '[:lower:]' | sed 's/[_ ]/-/g')
    
    # Remove multiple consecutive hyphens
    output=$(echo "$output" | sed 's/-\+/-/g')
    
    # Remove leading/trailing hyphens
    output=$(echo "$output" | sed 's/^-//;s/-$//')
    
    echo "$output"
}

# Function 1: Rename files by date (Preview)
rename_preview() {
    check_folder || return
    
    echo "\n${BLUE}ðŸ“¸ Preview: Renaming files based on creation date...${NC}"
    echo "===================================================="
    echo "Target: $TARGET_FOLDER"
    echo ""
    
    local count=0
    local rename_count=0
    local global_seq=1
    
    # Declare associative array for file type counting
    declare -A file_types
    
    temp_file=$(mktemp)
    
    echo "Collecting file metadata..."
    echo ""
    
    # First pass: count total files
    local total_files=$(find "$TARGET_FOLDER" -type f -not -name ".*" | wc -l | tr -d ' ')
    local processed=0
    
    # Second pass: collect metadata with progress
    find "$TARGET_FOLDER" -type f -not -name ".*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        ((processed++))
        draw_progress_bar $processed $total_files
        
        # Count file types
        ext="${file##*.}"
        ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
        
        created=$(mdls -name kMDItemContentCreationDate -raw "$file" 2>/dev/null)
        if [ -n "$created" ] && [ "$created" != "(null)" ]; then
            date_part=$(echo "$created" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}')
            if [ -n "$date_part" ]; then
                echo "$date_part|$file|$ext_lower" >> "$temp_file"
            fi
        fi
    done
    
    echo "\n"
    echo "${YELLOW}Files to be renamed:${NC}"
    echo "--------------------"
    
    sort "$temp_file" | while IFS='|' read -r date_part file ext_lower; do
        ((count++))
        
        # Count file types
        if [[ -n "${file_types[$ext_lower]}" ]]; then
            ((file_types[$ext_lower]++))
        else
            file_types[$ext_lower]=1
        fi
        
        dirname=$(dirname "$file")
        basename=$(basename "$file")
        
        new_name="${date_part}-$(printf "%03d" $global_seq).$ext_lower"
        new_path="$dirname/$new_name"
        
        if [ "$file" != "$new_path" ]; then
            ((rename_count++))
            echo "${GREEN}[$rename_count]${NC} $basename"
            echo "    ${CYAN}â†’${NC} $new_name"
            echo ""
        fi
        
        ((global_seq++))
    done
    
    # Count file types from temp file for statistics
    declare -A file_types_stats
    while IFS='|' read -r date_part file ext_lower; do
        if [[ -n "${file_types_stats[$ext_lower]}" ]]; then
            ((file_types_stats[$ext_lower]++))
        else
            file_types_stats[$ext_lower]=1
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    echo "${YELLOW}========================================${NC}"
    echo "${GREEN}Total files with dates: $count${NC}"
    echo "${GREEN}Files to rename: $rename_count${NC}"
    echo "${YELLOW}========================================${NC}"
    
    echo ""
    echo "${CYAN}File Type Statistics:${NC}"
    echo "--------------------"
    
    # Display file type statistics sorted by count
    for ext in "${(@k)file_types_stats}"; do
        printf "${GREEN}%-10s${NC} : %d files\n" ".$ext" "${file_types_stats[$ext]}"
    done | sort -t: -k2 -rn
    
    echo "\n${YELLOW}âœ“ Preview complete! No files were renamed.${NC}"
}

# Function 2: Rename files by date (Execute)
rename_execute() {
    check_folder || return
    
    echo "\n${RED}ðŸ“¸ Executing: Renaming files based on creation date...${NC}"
    echo "====================================================="
    echo "Target: $TARGET_FOLDER"
    echo ""
    
    local count=0
    local rename_count=0
    local global_seq=1
    
    # Declare associative array for file type counting
    declare -A file_types
    
    temp_file=$(mktemp)
    
    echo "Collecting file metadata..."
    echo ""
    
    # First pass: count total files
    local total_files=$(find "$TARGET_FOLDER" -type f -not -name ".*" | wc -l | tr -d ' ')
    local processed=0
    
    # Second pass: collect metadata with progress
    find "$TARGET_FOLDER" -type f -not -name ".*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        ((processed++))
        draw_progress_bar $processed $total_files
        
        # Count file types
        ext="${file##*.}"
        ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
        
        created=$(mdls -name kMDItemContentCreationDate -raw "$file" 2>/dev/null)
        if [ -n "$created" ] && [ "$created" != "(null)" ]; then
            date_part=$(echo "$created" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}')
            if [ -n "$date_part" ]; then
                echo "$date_part|$file|$ext_lower" >> "$temp_file"
            fi
        fi
    done
    
    echo "\n"
    echo "${YELLOW}Renaming files...${NC}"
    echo "-----------------"
    echo ""
    
    # Count total files to rename
    local total_to_rename=$(wc -l < "$temp_file" | tr -d ' ')
    local renamed=0
    
    sort "$temp_file" | while IFS='|' read -r date_part file ext_lower; do
        ((count++))
        
        dirname=$(dirname "$file")
        basename=$(basename "$file")
        
        new_name="${date_part}-$(printf "%03d" $global_seq).$ext_lower"
        new_path="$dirname/$new_name"
        
        if [ "$file" != "$new_path" ]; then
            mv "$file" "$new_path"
            ((rename_count++))
            ((renamed++))
            draw_progress_bar $renamed $total_to_rename
        fi
        
        ((global_seq++))
    done
    
    # Count file types from temp file for statistics
    declare -A file_types_stats
    while IFS='|' read -r date_part file ext_lower; do
        if [[ -n "${file_types_stats[$ext_lower]}" ]]; then
            ((file_types_stats[$ext_lower]++))
        else
            file_types_stats[$ext_lower]=1
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    echo "\n"
    echo "${YELLOW}========================================${NC}"
    echo "${GREEN}Total files processed: $count${NC}"
    echo "${GREEN}Files renamed: $rename_count${NC}"
    echo "${YELLOW}========================================${NC}"
    
    echo ""
    echo "${CYAN}File Type Statistics:${NC}"
    echo "--------------------"
    
    # Display file type statistics sorted by count
    for ext in "${(@k)file_types_stats}"; do
        printf "${GREEN}%-10s${NC} : %d files\n" ".$ext" "${file_types_stats[$ext]}"
    done | sort -t: -k2 -rn
    
    echo "\n${GREEN}âœ“ Done!${NC}"
}

# Function 3: Remove version tags (Preview)
remove_tags_preview() {
    check_folder || return
    
    echo "\n${BLUE}ðŸ·ï¸  Preview: Removing version tags...${NC}"
    echo "====================================="
    echo "Target: $TARGET_FOLDER"
    
    find "$TARGET_FOLDER" -type f -name "*-v[0-9]*.*" -not -name ".*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        newname=$(echo "$file" | sed 's/-v[0-9]*\././')
        echo "$file --> $newname"
    done
    
    echo "\n${YELLOW}âœ“ Preview complete! No files were renamed.${NC}"
}

# Function 4: Remove version tags (Execute)
remove_tags_execute() {
    check_folder || return
    
    echo "\n${RED}ðŸ·ï¸  Executing: Removing version tags...${NC}"
    echo "======================================="
    echo "Target: $TARGET_FOLDER"
    
    find "$TARGET_FOLDER" -type f -name "*-v[0-9]*.*" -not -name ".*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        newname=$(echo "$file" | sed 's/-v[0-9]*\././')
        mv "$file" "$newname"
        echo "Renamed: $file --> $newname"
    done
    
    echo "\n${GREEN}âœ“ Done!${NC}"
}

# Function 5: Move duplicate filenames (Preview)
move_duplicates_preview() {
    check_folder || return
    
    echo "\n${BLUE}ðŸ“ Preview: Moving duplicate filenames...${NC}"
    echo "========================================="
    echo "Target: $TARGET_FOLDER"
    
    find "$TARGET_FOLDER" -type f -name "* ([0-9])*.*" -not -name ".*" ! -path "*/duplicates/*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        echo "Would move: $file --> $TARGET_FOLDER/duplicates/"
    done
    
    echo "\n${YELLOW}âœ“ Preview complete! No files were moved.${NC}"
}

# Function 6: Move duplicate filenames (Execute)
move_duplicates_execute() {
    check_folder || return
    
    echo "\n${RED}ðŸ“ Executing: Moving duplicate filenames...${NC}"
    echo "==========================================="
    echo "Target: $TARGET_FOLDER"
    
    # Create duplicates folder in target directory
    mkdir -p "$TARGET_FOLDER/duplicates"
    
    find "$TARGET_FOLDER" -type f -name "* ([0-9])*.*" -not -name ".*" ! -path "*/duplicates/*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        mv "$file" "$TARGET_FOLDER/duplicates/"
        echo "Moved: $file"
    done
    
    echo "\n${GREEN}âœ“ Done! Files moved to $TARGET_FOLDER/duplicates/${NC}"
}

# Function 7: Convert to param-case (Preview)
param_case_preview() {
    check_folder || return
    
    echo "\n${BLUE}ðŸ”¤ Preview: Converting files and folders to param-case...${NC}"
    echo "==========================================================="
    echo "Target: $TARGET_FOLDER"
    echo ""
    
    local file_count=0
    local dir_count=0
    local file_rename_count=0
    local dir_rename_count=0
    
    # Process directories first (deepest first)
    echo "${CYAN}Folders to be renamed:${NC}"
    echo "----------------------"
    find "$TARGET_FOLDER" -depth -type d -not -name ".*" ! -path "*/duplicates/*" | while IFS= read -r dir; do
        # Skip if basename starts with dot or is the target folder itself
        basename=$(basename "$dir")
        [[ "$basename" == .* ]] && continue
        [[ "$dir" == "$TARGET_FOLDER" ]] && continue
        
        ((dir_count++))
        
        parent=$(dirname "$dir")
        new_dirname=$(to_param_case "$basename")
        new_path="$parent/$new_dirname"
        
        # Only show if there's a change
        if [ "$dir" != "$new_path" ]; then
            ((dir_rename_count++))
            echo "${GREEN}[$dir_rename_count]${NC} $basename/"
            echo "    ${CYAN}â†’${NC} $new_dirname/"
            echo ""
        fi
    done
    
    echo ""
    echo "${CYAN}Files to be renamed:${NC}"
    echo "--------------------"
    
    # Process files
    find "$TARGET_FOLDER" -type f -not -name ".*" ! -path "*/duplicates/*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        ((file_count++))
        
        dirname=$(dirname "$file")
        filename="${basename%.*}"
        ext="${basename##*.}"
        
        # Convert extension to lowercase
        ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
        
        # Convert filename to param-case
        new_filename=$(to_param_case "$filename")
        
        # Construct new path
        if [[ "$basename" == *.* ]]; then
            new_name="${new_filename}.${ext_lower}"
        else
            new_name="${new_filename}"
        fi
        
        new_path="$dirname/$new_name"
        
        # Only show if there's a change
        if [ "$file" != "$new_path" ]; then
            ((file_rename_count++))
            echo "${GREEN}[$file_rename_count]${NC} $basename"
            echo "    ${CYAN}â†’${NC} $new_name"
            echo ""
        fi
    done
    
    echo "${YELLOW}========================================${NC}"
    echo "${GREEN}Total folders scanned: $dir_count${NC}"
    echo "${GREEN}Folders to rename: $dir_rename_count${NC}"
    echo "${GREEN}Total files scanned: $file_count${NC}"
    echo "${GREEN}Files to rename: $file_rename_count${NC}"
    echo "${YELLOW}========================================${NC}"
    
    echo "\n${YELLOW}âœ“ Preview complete! No files or folders were renamed.${NC}"
}

# Function 8: Convert to param-case (Execute)
param_case_execute() {
    check_folder || return
    
    echo "\n${RED}ðŸ”¤ Executing: Converting files and folders to param-case...${NC}"
    echo "============================================================="
    echo "Target: $TARGET_FOLDER"
    echo ""
    
    local dir_rename_count=0
    local file_rename_count=0
    
    # Create temporary files to store rename operations
    temp_dir_file=$(mktemp)
    temp_file_file=$(mktemp)
    
    # First pass: collect all directory renames (deepest first)
    find "$TARGET_FOLDER" -depth -type d -not -name ".*" ! -path "*/duplicates/*" | while IFS= read -r dir; do
        # Skip if basename starts with dot or is the target folder itself
        basename=$(basename "$dir")
        [[ "$basename" == .* ]] && continue
        [[ "$dir" == "$TARGET_FOLDER" ]] && continue
        
        parent=$(dirname "$dir")
        new_dirname=$(to_param_case "$basename")
        new_path="$parent/$new_dirname"
        
        # Only add if there's a change
        if [ "$dir" != "$new_path" ]; then
            echo "$dir|$new_path" >> "$temp_dir_file"
        fi
    done
    
    # Count total directories to rename
    local total_dirs_to_rename=$(wc -l < "$temp_dir_file" | tr -d ' ')
    
    if [ "$total_dirs_to_rename" -gt 0 ]; then
        echo "${YELLOW}Renaming folders...${NC}"
        echo ""
        
        # Rename directories (deepest first to avoid path issues)
        while IFS='|' read -r old_path new_path; do
            # Check if target exists and is different (case-insensitive filesystem issue)
            # Use a temporary name to handle case-only changes
            if [ -e "$new_path" ]; then
                # Get the actual basename to compare (case-sensitive)
                old_basename=$(basename "$old_path")
                new_basename=$(basename "$new_path")
                
                # If only case differs, use a temporary name
                if [[ "${old_basename:l}" == "${new_basename:l}" ]] && [[ "$old_basename" != "$new_basename" ]]; then
                    temp_path="${new_path}.tmp_rename_$$"
                    mv "$old_path" "$temp_path"
                    mv "$temp_path" "$new_path"
                else
                    # Real conflict - add number suffix
                    parent=$(dirname "$new_path")
                    basename=$(basename "$new_path")
                    
                    counter=1
                    while [ -e "$parent/${basename}-${counter}" ]; do
                        ((counter++))
                    done
                    new_path="$parent/${basename}-${counter}"
                    mv "$old_path" "$new_path"
                fi
            else
                mv "$old_path" "$new_path"
            fi
            
            ((dir_rename_count++))
            draw_progress_bar $dir_rename_count $total_dirs_to_rename
        done < "$temp_dir_file"
        
        echo "\n"
    fi
    
    # Second pass: collect all file renames
    find "$TARGET_FOLDER" -type f -not -name ".*" ! -path "*/duplicates/*" | while IFS= read -r file; do
        # Skip if basename starts with dot
        basename=$(basename "$file")
        [[ "$basename" == .* ]] && continue
        
        dirname=$(dirname "$file")
        filename="${basename%.*}"
        ext="${basename##*.}"
        
        # Convert extension to lowercase
        ext_lower=$(echo "$ext" | tr '[:upper:]' '[:lower:]')
        
        # Convert filename to param-case
        new_filename=$(to_param_case "$filename")
        
        # Construct new path
        if [[ "$basename" == *.* ]]; then
            new_name="${new_filename}.${ext_lower}"
        else
            new_name="${new_filename}"
        fi
        
        new_path="$dirname/$new_name"
        
        # Only add if there's a change
        if [ "$file" != "$new_path" ]; then
            echo "$file|$new_path" >> "$temp_file_file"
        fi
    done
    
    # Count total files to rename
    local total_files_to_rename=$(wc -l < "$temp_file_file" | tr -d ' ')
    
    if [ "$total_files_to_rename" -gt 0 ]; then
        echo "${YELLOW}Renaming files...${NC}"
        echo ""
        
        # Rename files
        while IFS='|' read -r old_path new_path; do
            # Check if target exists and is different (case-insensitive filesystem issue)
            # Use a temporary name to handle case-only changes
            if [ -e "$new_path" ]; then
                # Get the actual basename to compare (case-sensitive)
                old_basename=$(basename "$old_path")
                new_basename=$(basename "$new_path")
                
                # If only case differs, use a temporary name
                if [[ "${old_basename:l}" == "${new_basename:l}" ]] && [[ "$old_basename" != "$new_basename" ]]; then
                    temp_path="${new_path}.tmp_rename_$$"
                    mv "$old_path" "$temp_path"
                    mv "$temp_path" "$new_path"
                else
                    # Real conflict - add number suffix
                    dirname=$(dirname "$new_path")
                    basename=$(basename "$new_path")
                    filename="${basename%.*}"
                    ext="${basename##*.}"
                    
                    counter=1
                    if [[ "$basename" == *.* ]]; then
                        while [ -e "$dirname/${filename}-${counter}.${ext}" ]; do
                            ((counter++))
                        done
                        new_path="$dirname/${filename}-${counter}.${ext}"
                    else
                        while [ -e "$dirname/${basename}-${counter}" ]; do
                            ((counter++))
                        done
                        new_path="$dirname/${basename}-${counter}"
                    fi
                    mv "$old_path" "$new_path"
                fi
            else
                mv "$old_path" "$new_path"
            fi
            
            ((file_rename_count++))
            draw_progress_bar $file_rename_count $total_files_to_rename
        done < "$temp_file_file"
        
        echo "\n"
    fi
    
    rm -f "$temp_dir_file" "$temp_file_file"
    
    if [ "$total_dirs_to_rename" -eq 0 ] && [ "$total_files_to_rename" -eq 0 ]; then
        echo "${YELLOW}No files or folders need to be renamed.${NC}"
        return
    fi
    
    echo "${YELLOW}========================================${NC}"
    echo "${GREEN}Folders renamed: $dir_rename_count${NC}"
    echo "${GREEN}Files renamed: $file_rename_count${NC}"
    echo "${YELLOW}========================================${NC}"
    
    echo "\n${GREEN}âœ“ Done!${NC}"
}

# Function 9: Run all previews
run_all_previews() {
    check_folder || return
    
    rename_preview
    remove_tags_preview
    move_duplicates_preview
    param_case_preview
}

# Function 10: Execute all actions
execute_all() {
    check_folder || return
    
    echo "\n${RED}âš ï¸  WARNING: This will execute all actions!${NC}"
    echo "Target folder: $TARGET_FOLDER"
    echo "Press Enter to continue or Ctrl+C to cancel..."
    read
    
    rename_execute
    remove_tags_execute
    move_duplicates_execute
    param_case_execute
    
    echo "\n${GREEN}âœ“ All actions completed!${NC}"
}

# Function 11: Delete backup files
delete_backups() {
    check_folder || return
    
    echo "\n${YELLOW}Deleting exiftool backup files in $TARGET_FOLDER...${NC}"
    exiftool -delete_original! -r "$TARGET_FOLDER"
    echo "${GREEN}âœ“ Backup files deleted!${NC}"
}

# Parse command line arguments
if [[ $# -gt 0 ]]; then
    # Expand ~ to home directory
    INPUT_PATH="${1/#\~/$HOME}"
    
    if [[ -d "$INPUT_PATH" ]]; then
        TARGET_FOLDER="$INPUT_PATH"
        echo "${GREEN}âœ“ Using folder from parameter: $TARGET_FOLDER${NC}"
    else
        echo "${RED}âœ— Error: Folder '$INPUT_PATH' does not exist!${NC}"
        echo "${YELLOW}Usage: $0 [folder_path]${NC}"
        exit 1
    fi
else
    # No parameter provided, show folder selection
    echo "${CYAN}Welcome to File Organiser!${NC}"
    select_folder
fi

# Main loop
while true; do
    show_menu
    echo -n "Select an option: "
    read choice
    
    case $choice in
        1) rename_preview ;;
        2) rename_execute ;;
        3) remove_tags_preview ;;
        4) remove_tags_execute ;;
        5) move_duplicates_preview ;;
        6) move_duplicates_execute ;;
        7) param_case_preview ;;
        8) param_case_execute ;;
        9) run_all_previews ;;
        a|A) execute_all ;;
        d|D) delete_backups ;;
        f|F) select_folder ;;
        0) echo "\n${GREEN}Goodbye!${NC}"; exit 0 ;;
        *) echo "\n${RED}Invalid option. Please try again.${NC}" ;;
    esac
    
    echo "\n${YELLOW}Press Enter to continue...${NC}"
    read
done